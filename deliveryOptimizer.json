{"files":[{"id":"d320d55b-4f4f-4df9-8ef3-05f2fe6ef7c7","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"America/New_York\",\n  \"dependencies\": {\n  },\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\"\n}"},{"id":"22368d19-bba1-4e8d-bbdd-b10a7bd01db4","name":"deliveryOptimizer","type":"server_js","source":"/**\n * DeliveryOptimizer - Google Apps Script for managing and optimizing product deliveries\n * \n * This script helps manage deliveries across multiple properties from various stores,\n * optimizing for minimal deliveries while respecting delivery capacity constraints.\n * \n * Features:\n * - Analyzes property inventory needs\n * - Assigns orders to stores based on availability and delivery capacity\n * - Consolidates partial deliveries when possible\n * - Tracks and updates inventory\n * - Provides detailed reporting\n */\n\n// Global constants\nconst MAX_DELIVERY_CAPACITY \u003d 16; // Maximum stacks per delivery\nconst DELIVERY_FEE \u003d 200; // Cost per delivery\nconst REQUIRED_SHEETS \u003d [\"Properties\", \"Items and Stores\", \"Order Optimization\", \"Summary\"];\nconst PROPERTY_INFO \u003d {\n  \"Bungalow\": {stacksNeededCol: 5, currentInventoryCol: 3},\n  \"Barn\": {stacksNeededCol: 9, currentInventoryCol: 8},\n  \"Docks Warehouse\": {stacksNeededCol: 13, currentInventoryCol: 12}\n};\n\n/**\n * Main function to optimize deliveries across all properties\n */\nfunction optimizeDeliveries() {\n  const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n  \n  // Validate sheets and get data\n  try {\n    const sheets \u003d validateSheets(ss);\n    const storeQueue \u003d initializeStoreQueue();\n    \n    // Clear and reset output sheets\n    sheets.optimizationSheet.clear();\n    \n    // Get data\n    const propertiesData \u003d getPropertiesData(sheets.propertiesSheet);\n    const itemsData \u003d getItemsAndStoresData(sheets.itemsAndStoresSheet);\n    \n    // Process each property\n    const summaryData \u003d processAllProperties(propertiesData, itemsData, sheets.optimizationSheet, storeQueue);\n    \n    // Format optimization sheet\n    formatSheet(sheets.optimizationSheet);\n    \n    // Update summary sheet\n    updateSummarySheet(summaryData, sheets.summarySheet);\n    \n    Logger.log(\"Delivery optimization completed successfully\");\n  } catch (error) {\n    Logger.log(`Error: ${error.message}`);\n    SpreadsheetApp.getUi().alert(`Error: ${error.message}`);\n  }\n}\n\n/**\n * Validates that all required sheets exist\n * @param {SpreadsheetApp.Spreadsheet} ss - The active spreadsheet\n * @return {Object} Object containing sheet references\n */\nfunction validateSheets(ss) {\n  const sheets \u003d {};\n  const missingSheets \u003d [];\n  \n  REQUIRED_SHEETS.forEach(sheetName \u003d\u003e {\n    const sheet \u003d ss.getSheetByName(sheetName);\n    if (sheet) {\n      sheets[sheetName.toLowerCase().replace(/ /g, \"\") + \"Sheet\"] \u003d sheet;\n    } else {\n      missingSheets.push(sheetName);\n    }\n  });\n  \n  if (missingSheets.length \u003e 0) {\n    throw new Error(`Missing sheets: ${missingSheets.join(\", \")}`);\n  }\n  \n  return sheets;\n}\n\n/**\n * Initialize or retrieve the store queue for fair distribution\n * @return {Array} Array of store names in queue order\n */\nfunction initializeStoreQueue() {\n  const stores \u003d [\"Dan\u0027s Hardware\", \"Handy Hank\u0027s\", \"Albert Hoover\", \"Shirley Watts\", \n                  \"Salvador Moreno\", \"Gas-Mart Central\", \"Gas-Mart West\", \"Oscar\u0027s Store\"];\n  \n  let storeQueue \u003d PropertiesService.getScriptProperties().getProperty(\"storeQueue\");\n  if (!storeQueue) {\n    storeQueue \u003d stores;\n    PropertiesService.getScriptProperties().setProperty(\"storeQueue\", JSON.stringify(storeQueue));\n  } else {\n    storeQueue \u003d JSON.parse(storeQueue);\n    \n    // Ensure all stores are in the queue (in case stores were added)\n    stores.forEach(store \u003d\u003e {\n      if (!storeQueue.includes(store)) {\n        storeQueue.push(store);\n      }\n    });\n  }\n  \n  Logger.log(`Store queue: ${storeQueue.join(\u0027, \u0027)}`);\n  return storeQueue;\n}\n\n/**\n * Retrieves and validates data from Properties sheet\n * @param {SpreadsheetApp.Sheet} propertiesSheet - The Properties sheet\n * @return {Array} Array of property data rows\n */\nfunction getPropertiesData(propertiesSheet) {\n  const lastRow \u003d propertiesSheet.getLastRow();\n  if (lastRow \u003c 3) {\n    throw new Error(\"Properties sheet must have data starting at row 3\");\n  }\n  \n  return propertiesSheet.getRange(3, 1, lastRow - 2, 13).getValues();\n}\n\n/**\n * Retrieves and validates data from Items and Stores sheet\n * @param {SpreadsheetApp.Sheet} itemsAndStoresSheet - The Items and Stores sheet\n * @return {Array} Array of item data rows\n */\nfunction getItemsAndStoresData(itemsAndStoresSheet) {\n  const lastRow \u003d itemsAndStoresSheet.getLastRow();\n  if (lastRow \u003c 2) {\n    throw new Error(\"Items and Stores sheet must have data starting at row 2\");\n  }\n  \n  return itemsAndStoresSheet.getRange(2, 1, lastRow - 1, 11).getValues();\n}\n\n/**\n * Process all properties to generate optimized deliveries\n * @param {Array} propertiesData - Data from Properties sheet\n * @param {Array} itemsData - Data from Items and Stores sheet\n * @param {SpreadsheetApp.Sheet} outputSheet - Sheet to write results\n * @param {Array} storeQueue - Store queue for fair distribution\n * @return {Array} Summary data for all processed deliveries\n */\nfunction processAllProperties(propertiesData, itemsData, outputSheet, storeQueue) {\n  const properties \u003d Object.keys(PROPERTY_INFO);\n  const stores \u003d [\"Dan\u0027s Hardware\", \"Handy Hank\u0027s\", \"Albert Hoover\", \"Shirley Watts\", \n                 \"Salvador Moreno\", \"Gas-Mart Central\", \"Gas-Mart West\", \"Oscar\u0027s Store\"];\n  \n  let row \u003d 1;\n  let summaryData \u003d [];\n  \n  // Process each property\n  properties.forEach(property \u003d\u003e {\n    const propertyNeeds \u003d identifyPropertyNeeds(property, propertiesData, itemsData);\n    \n    if (propertyNeeds.length \u003d\u003d\u003d 0) {\n      Logger.log(`No items needed for ${property}`);\n      return;\n    }\n    \n    // Create initial delivery plan\n    const deliveryPlan \u003d createDeliveryPlan(property, propertyNeeds, storeQueue);\n    \n    // Write delivery plan to sheet and collect summary data\n    const propertySummary \u003d writeDeliveryPlan(property, deliveryPlan, outputSheet, row);\n    summaryData \u003d summaryData.concat(propertySummary);\n    \n    // Update row position for next property\n    row +\u003d propertySummary.reduce((total, entry) \u003d\u003e {\n      // Each store gets a header row + items rows + total row + 2 blank rows\n      return total + entry[4] + 4;\n    }, 0);\n    \n    Logger.log(`Processed ${property}: ${propertySummary.length} stores used`);\n  });\n  \n  // Rotate store queue based on usage\n  PropertiesService.getScriptProperties().setProperty(\"storeQueue\", JSON.stringify(storeQueue));\n  \n  return summaryData;\n}\n\n/**\n * Identify items needed for a specific property\n * @param {string} property - The property name\n * @param {Array} propertiesData - Data from Properties sheet\n * @param {Array} itemsData - Data from Items and Stores sheet\n * @return {Array} Array of needed items with their details\n */\nfunction identifyPropertyNeeds(property, propertiesData, itemsData) {\n  const propertyInfo \u003d PROPERTY_INFO[property];\n  const stacksNeededCol \u003d propertyInfo.stacksNeededCol - 1; // Convert to 0-based index\n  const stores \u003d [\"Dan\u0027s Hardware\", \"Handy Hank\u0027s\", \"Albert Hoover\", \"Shirley Watts\", \n                 \"Salvador Moreno\", \"Gas-Mart Central\", \"Gas-Mart West\", \"Oscar\u0027s Store\"];\n  \n  const propertyNeeds \u003d [];\n  \n  propertiesData.forEach((row, index) \u003d\u003e {\n    const item \u003d row[0];\n    const stacksNeeded \u003d row[stacksNeededCol];\n    \n    if (stacksNeeded \u003e 0 \u0026\u0026 index \u003c itemsData.length) {\n      const itemInfo \u003d itemsData[index];\n      const stackSize \u003d itemInfo[1];\n      const costPerItem \u003d itemInfo[2];\n      \n      if (stackSize \u003c\u003d 0 || costPerItem \u003c 0) {\n        Logger.log(`Warning: Invalid data for ${item}: stackSize\u003d${stackSize}, costPerItem\u003d${costPerItem}`);\n        return;\n      }\n      \n      // Find which stores carry this item\n      const availableStores \u003d [];\n      stores.forEach((store, storeIndex) \u003d\u003e {\n        if (itemInfo[3 + storeIndex] \u003d\u003d\u003d \"Yes\") {\n          availableStores.push(store);\n        }\n      });\n      \n      if (availableStores.length \u003e 0) {\n        propertyNeeds.push({\n          item,\n          stacksNeeded,\n          stackSize,\n          costPerItem,\n          availableStores,\n          remainingStacks: stacksNeeded\n        });\n        \n        Logger.log(`${property} needs ${stacksNeeded} stacks of ${item} (available at ${availableStores.length} stores)`);\n      } else {\n        Logger.log(`Warning: No stores available for ${item}`);\n      }\n    }\n  });\n  \n  // Sort by availability (ascending) and quantity needed (descending)\n  propertyNeeds.sort((a, b) \u003d\u003e {\n    if (a.availableStores.length !\u003d\u003d b.availableStores.length) {\n      return a.availableStores.length - b.availableStores.length;\n    }\n    return b.stacksNeeded - a.stacksNeeded;\n  });\n  \n  return propertyNeeds;\n}\n\n/**\n * Create an optimized delivery plan for a property\n * @param {string} property - The property name\n * @param {Array} propertyNeeds - Items needed for the property\n * @param {Array} storeQueue - Store queue for fair distribution\n * @return {Object} Delivery plan organized by store\n */\nfunction createDeliveryPlan(property, propertyNeeds, storeQueue) {\n  const stores \u003d [...new Set(propertyNeeds.flatMap(item \u003d\u003e item.availableStores))];\n  const deliveryPlan \u003d {};\n  \n  // Initialize store delivery tracking\n  stores.forEach(store \u003d\u003e {\n    deliveryPlan[store] \u003d {\n      deliveries: [],\n      totalStacks: 0,\n      totalItems: 0,\n      totalCost: 0\n    };\n  });\n  \n  // First-pass: Assign items to their optimal stores\n  assignItemsToStores(propertyNeeds, deliveryPlan, storeQueue);\n  \n  // Second-pass: Consolidate partial deliveries when possible\n  consolidateDeliveries(propertyNeeds, deliveryPlan);\n  \n  // Final-pass: Calculate totals and finalize delivery plan\n  finalizeDeliveryPlan(deliveryPlan);\n  \n  return deliveryPlan;\n}\n\n/**\n * Assign items to stores using an optimized algorithm\n * @param {Array} items - Items to be assigned\n * @param {Object} deliveryPlan - Current delivery plan\n * @param {Array} storeQueue - Store queue for fair distribution\n */\nfunction assignItemsToStores(items, deliveryPlan, storeQueue) {\n  // Clone items to track remaining needs\n  let remainingItems \u003d [...items];\n  \n  // First pass: Items with limited store availability\n  remainingItems.sort((a, b) \u003d\u003e a.availableStores.length - b.availableStores.length);\n  \n  while (remainingItems.some(item \u003d\u003e item.remainingStacks \u003e 0)) {\n    // Sort store queue by usage\n    const sortedStores \u003d [...storeQueue].sort((a, b) \u003d\u003e {\n      const aDeliveries \u003d deliveryPlan[a]?.deliveries.length || 0;\n      const bDeliveries \u003d deliveryPlan[b]?.deliveries.length || 0;\n      return aDeliveries - bDeliveries;\n    });\n    \n    let assigned \u003d false;\n    \n    // Try to fill existing partial deliveries first\n    for (const store of sortedStores) {\n      if (!deliveryPlan[store]) continue;\n      \n      const deliveries \u003d deliveryPlan[store].deliveries;\n      if (deliveries.length \u003d\u003d\u003d 0 || deliveries[deliveries.length - 1].stacks \u003e\u003d MAX_DELIVERY_CAPACITY) {\n        continue; // No deliveries or last delivery is full\n      }\n      \n      const currentDelivery \u003d deliveries[deliveries.length - 1];\n      \n      // Try to add items to this partial delivery\n      for (const item of remainingItems) {\n        if (item.remainingStacks \u003d\u003d\u003d 0 || !item.availableStores.includes(store)) {\n          continue;\n        }\n        \n        const spaceLeft \u003d MAX_DELIVERY_CAPACITY - currentDelivery.stacks;\n        const stacksToAdd \u003d Math.min(item.remainingStacks, spaceLeft);\n        \n        if (stacksToAdd \u003e 0) {\n          // Add to delivery\n          currentDelivery.items.push({\n            item: item.item,\n            stacksNeeded: stacksToAdd,\n            stackSize: item.stackSize,\n            costPerItem: item.costPerItem\n          });\n          \n          currentDelivery.stacks +\u003d stacksToAdd;\n          item.remainingStacks -\u003d stacksToAdd;\n          assigned \u003d true;\n          \n          Logger.log(`Added ${stacksToAdd} stacks of ${item.item} to existing ${store} delivery (${currentDelivery.stacks}/${MAX_DELIVERY_CAPACITY})`);\n          \n          // Rotate store queue if delivery is now full\n          if (currentDelivery.stacks \u003e\u003d MAX_DELIVERY_CAPACITY) {\n            rotateStoreQueue(storeQueue, store);\n            break;\n          }\n        }\n      }\n    }\n    \n    // Create new deliveries if needed\n    if (!assigned) {\n      // Find most constrained item (fewest store options)\n      const targetItem \u003d remainingItems.find(item \u003d\u003e item.remainingStacks \u003e 0);\n      if (!targetItem) break;\n      \n      // Find best store for this item\n      const bestStore \u003d targetItem.availableStores.sort((a, b) \u003d\u003e {\n        // Prefer stores earlier in the queue\n        return storeQueue.indexOf(a) - storeQueue.indexOf(b);\n      })[0];\n      \n      if (!bestStore) {\n        Logger.log(`Warning: No available store for ${targetItem.item}`);\n        targetItem.remainingStacks \u003d 0; // Mark as unassignable\n        continue;\n      }\n      \n      // Create new delivery\n      const newDelivery \u003d {\n        items: [{\n          item: targetItem.item,\n          stacksNeeded: Math.min(targetItem.remainingStacks, MAX_DELIVERY_CAPACITY),\n          stackSize: targetItem.stackSize,\n          costPerItem: targetItem.costPerItem\n        }],\n        stacks: Math.min(targetItem.remainingStacks, MAX_DELIVERY_CAPACITY)\n      };\n      \n      targetItem.remainingStacks -\u003d newDelivery.items[0].stacksNeeded;\n      deliveryPlan[bestStore].deliveries.push(newDelivery);\n      \n      Logger.log(`Created new delivery from ${bestStore} with ${newDelivery.items[0].stacksNeeded} stacks of ${targetItem.item}`);\n      \n      // Try to fill this new delivery with compatible items\n      for (const item of remainingItems) {\n        if (item \u003d\u003d\u003d targetItem || item.remainingStacks \u003d\u003d\u003d 0 || !item.availableStores.includes(bestStore)) {\n          continue;\n        }\n        \n        const spaceLeft \u003d MAX_DELIVERY_CAPACITY - newDelivery.stacks;\n        if (spaceLeft \u003c\u003d 0) break;\n        \n        const stacksToAdd \u003d Math.min(item.remainingStacks, spaceLeft);\n        \n        if (stacksToAdd \u003e 0) {\n          newDelivery.items.push({\n            item: item.item,\n            stacksNeeded: stacksToAdd,\n            stackSize: item.stackSize,\n            costPerItem: item.costPerItem\n          });\n          \n          newDelivery.stacks +\u003d stacksToAdd;\n          item.remainingStacks -\u003d stacksToAdd;\n          \n          Logger.log(`Added ${stacksToAdd} stacks of ${item.item} to new ${bestStore} delivery (${newDelivery.stacks}/${MAX_DELIVERY_CAPACITY})`);\n        }\n      }\n      \n      // Rotate store queue if delivery is full\n      if (newDelivery.stacks \u003e\u003d MAX_DELIVERY_CAPACITY) {\n        rotateStoreQueue(storeQueue, bestStore);\n      }\n      \n      assigned \u003d true;\n    }\n    \n    // If no assignments were made, break to avoid infinite loop\n    if (!assigned) {\n      Logger.log(\"Warning: Could not assign remaining items\");\n      break;\n    }\n    \n    // Remove fully assigned items\n    remainingItems \u003d remainingItems.filter(item \u003d\u003e item.remainingStacks \u003e 0);\n  }\n}\n\n/**\n * Rotate a store to the end of the queue after a full delivery\n * @param {Array} storeQueue - Store queue to modify\n * @param {string} store - Store to rotate\n */\nfunction rotateStoreQueue(storeQueue, store) {\n  const index \u003d storeQueue.indexOf(store);\n  if (index !\u003d\u003d -1) {\n    storeQueue.splice(index, 1);\n    storeQueue.push(store);\n    Logger.log(`Rotated ${store} to end of queue: ${storeQueue.join(\u0027, \u0027)}`);\n  }\n}\n\n/**\n * Consolidate partial deliveries to minimize delivery count\n * @param {Array} items - All property items\n * @param {Object} deliveryPlan - Current delivery plan\n */\nfunction consolidateDeliveries(items, deliveryPlan) {\n  // Collect all partial deliveries\n  let partialDeliveries \u003d [];\n  for (const store in deliveryPlan) {\n    deliveryPlan[store].deliveries.forEach((delivery, index) \u003d\u003e {\n      if (delivery.stacks \u003c MAX_DELIVERY_CAPACITY) {\n        partialDeliveries.push({\n          store,\n          index,\n          delivery,\n          space: MAX_DELIVERY_CAPACITY - delivery.stacks\n        });\n      }\n    });\n  }\n  \n  // Sort by available space (ascending)\n  partialDeliveries.sort((a, b) \u003d\u003e a.space - b.space);\n  \n  // Try to merge pairs of partial deliveries\n  let merged;\n  do {\n    merged \u003d false;\n    \n    for (let i \u003d 0; i \u003c partialDeliveries.length; i++) {\n      const d1 \u003d partialDeliveries[i];\n      \n      for (let j \u003d i + 1; j \u003c partialDeliveries.length; j++) {\n        const d2 \u003d partialDeliveries[j];\n        \n        // Skip if same store or won\u0027t fit together\n        if (d1.store \u003d\u003d\u003d d2.store || d1.delivery.stacks + d2.delivery.stacks \u003e MAX_DELIVERY_CAPACITY) {\n          continue;\n        }\n        \n        // Find common store for all items in both deliveries\n        const allItems \u003d [...d1.delivery.items, ...d2.delivery.items];\n        const itemNames \u003d allItems.map(i \u003d\u003e i.item);\n        \n        // Get common stores for these items\n        const commonStores \u003d findCommonStores(itemNames, items);\n        \n        if (commonStores.length \u003e 0) {\n          // Take the first common store\n          const targetStore \u003d commonStores[0];\n          \n          // Create merged delivery\n          const mergedDelivery \u003d {\n            items: [...allItems],\n            stacks: d1.delivery.stacks + d2.delivery.stacks\n          };\n          \n          // Remove original deliveries\n          deliveryPlan[d1.store].deliveries.splice(d1.index, 1);\n          \n          // Adjust index if d2 is from same store and after d1\n          if (d2.store \u003d\u003d\u003d d1.store \u0026\u0026 d2.index \u003e d1.index) {\n            d2.index--;\n          }\n          \n          deliveryPlan[d2.store].deliveries.splice(d2.index, 1);\n          \n          // Add merged delivery to target store\n          if (!deliveryPlan[targetStore]) {\n            deliveryPlan[targetStore] \u003d {\n              deliveries: [],\n              totalStacks: 0,\n              totalItems: 0,\n              totalCost: 0\n            };\n          }\n          \n          deliveryPlan[targetStore].deliveries.push(mergedDelivery);\n          \n          Logger.log(`Merged deliveries from ${d1.store} and ${d2.store} into ${targetStore}`);\n          \n          // Rebuild partial deliveries list\n          partialDeliveries \u003d [];\n          for (const store in deliveryPlan) {\n            deliveryPlan[store].deliveries.forEach((delivery, index) \u003d\u003e {\n              if (delivery.stacks \u003c MAX_DELIVERY_CAPACITY) {\n                partialDeliveries.push({\n                  store,\n                  index,\n                  delivery,\n                  space: MAX_DELIVERY_CAPACITY - delivery.stacks\n                });\n              }\n            });\n          }\n          \n          partialDeliveries.sort((a, b) \u003d\u003e a.space - b.space);\n          merged \u003d true;\n          break;\n        }\n      }\n      \n      if (merged) break;\n    }\n  } while (merged);\n}\n\n/**\n * Find stores that can supply all the given items\n * @param {Array} itemNames - Names of items\n * @param {Array} allItems - Complete item data\n * @return {Array} Stores that can supply all items\n */\nfunction findCommonStores(itemNames, allItems) {\n  // Get all stores that carry each item\n  const storesByItem \u003d itemNames.map(itemName \u003d\u003e {\n    const itemData \u003d allItems.find(i \u003d\u003e i.item \u003d\u003d\u003d itemName);\n    return itemData ? itemData.availableStores : [];\n  });\n  \n  // Find intersection of all store arrays\n  if (storesByItem.length \u003d\u003d\u003d 0) return [];\n  \n  return storesByItem.reduce((acc, stores) \u003d\u003e {\n    return acc.filter(store \u003d\u003e stores.includes(store));\n  }, storesByItem[0]);\n}\n\n/**\n * Calculate totals and finalize the delivery plan\n * @param {Object} deliveryPlan - Delivery plan to finalize\n */\nfunction finalizeDeliveryPlan(deliveryPlan) {\n  for (const store in deliveryPlan) {\n    const plan \u003d deliveryPlan[store];\n    \n    // Skip stores with no deliveries\n    if (plan.deliveries.length \u003d\u003d\u003d 0) continue;\n    \n    // Calculate totals\n    plan.totalStacks \u003d 0;\n    plan.totalItems \u003d 0;\n    plan.totalCost \u003d 0;\n    \n    plan.deliveries.forEach(delivery \u003d\u003e {\n      let deliveryItemCost \u003d 0;\n      \n      delivery.items.forEach(item \u003d\u003e {\n        const itemsOrdered \u003d item.stacksNeeded * item.stackSize;\n        deliveryItemCost +\u003d itemsOrdered * item.costPerItem;\n        plan.totalStacks +\u003d item.stacksNeeded;\n        plan.totalItems +\u003d itemsOrdered;\n      });\n      \n      // Add item cost plus delivery fee\n      plan.totalCost +\u003d deliveryItemCost + DELIVERY_FEE;\n    });\n    \n    Logger.log(`${store}: ${plan.deliveries.length} deliveries, ${plan.totalStacks} stacks, $${plan.totalCost}`);\n  }\n}\n\n/**\n * Write the delivery plan to the output sheet\n * @param {string} property - The property name\n * @param {Object} deliveryPlan - Finalized delivery plan\n * @param {SpreadsheetApp.Sheet} sheet - Output sheet\n * @param {number} startRow - Starting row for output\n * @return {Array} Summary data for this property\n */\nfunction writeDeliveryPlan(property, deliveryPlan, sheet, startRow) {\n  let row \u003d startRow;\n  const summaryData \u003d [];\n  \n  // Process each store with deliveries\n  for (const store in deliveryPlan) {\n    const plan \u003d deliveryPlan[store];\n    \n    // Skip stores with no deliveries\n    if (plan.deliveries.length \u003d\u003d\u003d 0) continue;\n    \n    // Header\n    sheet.getRange(row, 1).setValue(`${property} - ${store}`);\n    row++;\n    sheet.getRange(row, 1, 1, 5).setValues([[\"Item\", \"Stacks Needed\", \"Delivery Number\", \"Items Ordered\", \"Cost\"]]);\n    row++;\n    \n    // Write deliveries\n    plan.deliveries.forEach((delivery, index) \u003d\u003e {\n      delivery.items.forEach(item \u003d\u003e {\n        const itemsOrdered \u003d item.stacksNeeded * item.stackSize;\n        const cost \u003d itemsOrdered * item.costPerItem;\n        \n        sheet.getRange(row, 1, 1, 5).setValues([\n          [item.item, item.stacksNeeded, index + 1, itemsOrdered, cost]\n        ]);\n        row++;\n      });\n    });\n    \n    // Total row\n    sheet.getRange(row, 1, 1, 5).setValues([\n      [\"Total\", plan.totalStacks, plan.deliveries.length, plan.totalItems, plan.totalCost]\n    ]);\n    row +\u003d 2; // Add space after each store\n    \n    // Add to summary data\n    summaryData.push([\n      property, \n      store, \n      plan.totalStacks, \n      plan.totalItems, \n      plan.deliveries.length, \n      plan.totalCost\n    ]);\n  }\n  \n  return summaryData;\n}\n\n/**\n * Update the summary sheet with delivery data\n * @param {Array} summaryData - Collected summary data\n * @param {SpreadsheetApp.Sheet} summarySheet - Summary sheet\n */\nfunction updateSummarySheet(summaryData, summarySheet) {\n  summarySheet.clear();\n  \n  if (summaryData.length \u003d\u003d\u003d 0) {\n    summarySheet.getRange(1, 1).setValue(\"No deliveries needed\");\n    return;\n  }\n  \n  // Header\n  summarySheet.getRange(1, 1, 1, 6).setValues([\n    [\"Property\", \"Store\", \"Total Stacks Ordered\", \"Total Items Ordered\", \"Total Deliveries\", \"Total Cost\"]\n  ]);\n  \n  // Data\n  summarySheet.getRange(2, 1, summaryData.length, 6).setValues(summaryData);\n  \n  // Totals\n  const totalStacks \u003d summaryData.reduce((sum, row) \u003d\u003e sum + row[2], 0);\n  const totalItems \u003d summaryData.reduce((sum, row) \u003d\u003e sum + row[3], 0);\n  const totalDeliveries \u003d summaryData.reduce((sum, row) \u003d\u003e sum + row[4], 0);\n  const totalCost \u003d summaryData.reduce((sum, row) \u003d\u003e sum + row[5], 0);\n  \n  summarySheet.getRange(summaryData.length + 2, 1, 1, 6).setValues([\n    [\"Total\", \"\", totalStacks, totalItems, totalDeliveries, totalCost]\n  ]);\n  \n  // Format\n  summarySheet.setFrozenRows(1);\n  summarySheet.setFrozenColumns(2);\n  \n  Logger.log(`Summary updated: ${totalDeliveries} deliveries, ${totalStacks} stacks, $${totalCost}`);\n}\n\n/**\n * Format a sheet with basic styling\n * @param {SpreadsheetApp.Sheet} sheet - Sheet to format\n */\nfunction formatSheet(sheet) {\n  // Freeze headers\n  sheet.setFrozenRows(1);\n  sheet.setFrozenColumns(1);\n  \n  // Protect sheet\n  try {\n    const protection \u003d sheet.protect().setDescription(`Protected ${sheet.getName()}`);\n    protection.setWarningOnly(false);\n    protection.removeEditors(protection.getEditors());\n  } catch (e) {\n    Logger.log(`Protection error: ${e.message}`);\n  }\n}\n\n/**\n * Process and fulfill the next pending order\n */\nfunction processNextOrder() {\n  const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n  \n  try {\n    // Validate sheets\n    const sheets \u003d validateSheets(ss);\n    const nextOrderSheet \u003d ss.getSheetByName(\"Next Order\");\n    \n    if (!nextOrderSheet) {\n      throw new Error(\"Missing sheet: Next Order\");\n    }\n    \n    // Run optimization to refresh data\n    optimizeDeliveries();\n    \n    // Clear and set up Next Order sheet\n    nextOrderSheet.clear();\n    nextOrderSheet.getRange(1, 1, 1, 7).setValues([[\"Item\", \"Stacks Needed\", \"Items Ordered\", \"Cost\", \"Property\", \"Store\", \"Status\"]]);\n    \n    // Get optimization data\n    const data \u003d sheets.optimizationSheet.getRange(1, 1, sheets.optimizationSheet.getLastRow(), 5).getValues();\n    \n    // Process first delivery\n    const firstDelivery \u003d findFirstDelivery(data);\n    \n    if (firstDelivery.items.length \u003d\u003d\u003d 0) {\n      nextOrderSheet.getRange(2, 1).setValue(\"No pending orders\");\n      return;\n    }\n    \n    // Write to Next Order sheet\n    let row \u003d 2;\n    firstDelivery.items.forEach(item \u003d\u003e {\n      nextOrderSheet.getRange(row, 1, 1, 7).setValues([\n        [item.item, item.stacksNeeded, item.itemsOrdered, item.cost, firstDelivery.property, firstDelivery.store, false]\n      ]);\n      row++;\n    });\n    \n    // Update inventory\n    updateInventory(firstDelivery);\n    \n    Logger.log(`Processed next order: ${firstDelivery.property} from ${firstDelivery.store}`);\n  } catch (error) {\n    Logger.log(`Error: ${error.message}`);\n    SpreadsheetApp.getUi().alert(`Error: ${error.message}`);\n  }\n}\n\n/**\n * Find the first delivery in the optimization data\n * @param {Array} data - Data from optimization sheet\n * @return {Object} First delivery information\n */\nfunction findFirstDelivery(data) {\n  let property \u003d \"\", store \u003d \"\";\n  let items \u003d [];\n  let foundHeader \u003d false;\n  \n  for (let i \u003d 0; i \u003c data.length; i++) {\n    const row \u003d data[i];\n    \n    // Check if this is a property-store header\n    if (row[0] \u0026\u0026 row[0].includes(\" - \")) {\n      [property, store] \u003d row[0].split(\" - \");\n      foundHeader \u003d true;\n      continue;\n    }\n    \n    // Skip non-data rows\n    if (!foundHeader || !row[0] || row[0] \u003d\u003d\u003d \"Item\" || row[0] \u003d\u003d\u003d \"Total\") {\n      continue;\n    }\n    \n    // Only collect items for delivery number 1\n    if (row[2] \u003d\u003d\u003d 1) {\n      items.push({\n        item: row[0],\n        stacksNeeded: row[1],\n        itemsOrdered: row[3],\n        cost: row[4]\n      });\n    } else if (items.length \u003e 0 \u0026\u0026 row[2] \u003e 1) {\n      // Once we see delivery number \u003e 1, we\u0027ve processed the first delivery\n      break;\n    }\n  }\n  \n  return {\n    property,\n    store,\n    items\n  };\n}\n\n/**\n * Update inventory based on order fulfillment\n * @param {Object} delivery - Delivery information\n */\nfunction updateInventory(delivery) {\n  const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n  const propertiesSheet \u003d ss.getSheetByName(\"Properties\");\n  \n  if (!propertiesSheet) {\n    Logger.log(\"Error: Properties sheet not found\");\n    return;\n  }\n  \n  // Map properties to their inventory columns\n  const propertyInventoryColumns \u003d {\n    \"Bungalow\": 3,         // Column C\n    \"Barn\": 8,             // Column H\n    \"Docks Warehouse\": 12  // Column L\n  };\n  \n  const inventoryCol \u003d propertyInventoryColumns[delivery.property];\n  if (!inventoryCol) {\n    Logger.log(`Error: Unknown property ${delivery.property}`);\n    return;\n  }\n  \n  // Get properties data\n  const propertiesLastRow \u003d propertiesSheet.getLastRow();\n  const propertiesData \u003d propertiesSheet.getRange(3, 1, propertiesLastRow - 2, 13).getValues();\n  \n  // Update inventory for each item\n  let updatedItems \u003d 0;\n  \n  delivery.items.forEach(item \u003d\u003e {\n    // Find the item in properties data\n    for (let i \u003d 0; i \u003c propertiesData.length; i++) {\n      if (propertiesData[i][0] \u003d\u003d\u003d item.item) {\n        // Get current inventory and update it\n        const currentInventory \u003d propertiesData[i][inventoryCol - 1] || 0;\n        const newInventory \u003d currentInventory + item.itemsOrdered;\n        \n        // Update the cell\n        propertiesSheet.getRange(i + 3, inventoryCol).setValue(newInventory);\n        \n        Logger.log(`Updated ${delivery.property} inventory for ${item.item}: ${currentInventory} → ${newInventory}`);\n        updatedItems++;\n        break;\n      }\n    }\n  });\n  \n  if (updatedItems \u003d\u003d\u003d 0) {\n    Logger.log(\"Warning: No inventory was updated\");\n  } else {\n    Logger.log(`Successfully updated inventory for ${updatedItems} items`);\n  }\n}\n\n/**\n * Add menu items when the spreadsheet opens\n */\nfunction onOpen() {\n  SpreadsheetApp.getUi()\n    .createMenu(\"Schedule I\")\n    .addItem(\"Optimize Deliveries\", \"optimizeDeliveries\")\n    .addItem(\"Process Next Order\", \"processNextOrder\")\n    .addToUi();\n}\n\n/**\n * Utility function to create a test environment\n * This can be useful for debugging or setting up a new spreadsheet\n */\nfunction setupTestEnvironment() {\n  const ss \u003d SpreadsheetApp.getActiveSpreadsheet();\n  \n  // Check if sheets already exist\n  const existingSheets \u003d ss.getSheets().map(sheet \u003d\u003e sheet.getName());\n  const requiredSheets \u003d [\"Properties\", \"Items and Stores\", \"Order Optimization\", \"Summary\", \"Next Order\"];\n  \n  // Create missing sheets\n  requiredSheets.forEach(sheetName \u003d\u003e {\n    if (!existingSheets.includes(sheetName)) {\n      const sheet \u003d ss.insertSheet(sheetName);\n      Logger.log(`Created sheet: ${sheetName}`);\n      \n      // Set up basic structure based on sheet type\n      switch(sheetName) {\n        case \"Properties\":\n          setupPropertiesSheet(sheet);\n          break;\n        case \"Items and Stores\":\n          setupItemsAndStoresSheet(sheet);\n          break;\n        default:\n          // Other sheets will be populated by the script\n          break;\n      }\n    }\n  });\n  \n  Logger.log(\"Test environment setup complete\");\n}\n\n/**\n * Setup the Properties sheet with sample data\n * @param {SpreadsheetApp.Sheet} sheet - The Properties sheet\n */\nfunction setupPropertiesSheet(sheet) {\n  // Headers\n  sheet.getRange(1, 1).setValue(\"Properties Inventory and Order Management\");\n  \n  const headers \u003d [\n    [\"Item\", \"Bungalow\", \"\", \"\", \"\", \"Barn\", \"\", \"\", \"\", \"Docks Warehouse\", \"\", \"\", \"\"],\n    [\"\", \"Current\", \"Min\", \"Max\", \"Stacks Needed\", \"Current\", \"Min\", \"Max\", \"Stacks Needed\", \"Current\", \"Min\", \"Max\", \"Stacks Needed\"]\n  ];\n  \n  sheet.getRange(1, 1, 2, 13).setValues(headers);\n  \n  // Sample data\n  const sampleItems \u003d [\n    [\"Lumber\", 50, 25, 100, \"\u003dIF(B3\u003cC3,D3-B3,0)\", 30, 20, 80, \"\u003dIF(F3\u003cG3,H3-F3,0)\", 40, 30, 100, \"\u003dIF(J3\u003cK3,L3-J3,0)\"],\n    [\"Plywood\", 15, 10, 40, \"\u003dIF(B4\u003cC4,D4-B4,0)\", 20, 15, 60, \"\u003dIF(F4\u003cG4,H4-F4,0)\", 25, 20, 80, \"\u003dIF(J4\u003cK4,L4-J4,0)\"],\n    [\"Nails\", 200, 150, 500, \"\u003dIF(B5\u003cC5,D5-B5,0)\", 180, 150, 400, \"\u003dIF(F5\u003cG5,H5-F5,0)\", 220, 200, 600, \"\u003dIF(J5\u003cK5,L5-J5,0)\"],\n    [\"Screws\", 180, 120, 400, \"\u003dIF(B6\u003cC6,D6-B6,0)\", 150, 100, 300, \"\u003dIF(F6\u003cG6,H6-F6,0)\", 200, 150, 450, \"\u003dIF(J6\u003cK6,L6-J6,0)\"]\n  ];\n  \n  sheet.getRange(3, 1, sampleItems.length, 13).setValues(sampleItems);\n  \n  // Format\n  sheet.setFrozenRows(2);\n  sheet.setFrozenColumns(1);\n}\n\n/**\n * Setup the Items and Stores sheet with sample data\n * @param {SpreadsheetApp.Sheet} sheet - The Items and Stores sheet\n */\nfunction setupItemsAndStoresSheet(sheet) {\n  // Headers\n  const storeNames \u003d [\"Dan\u0027s Hardware\", \"Handy Hank\u0027s\", \"Albert Hoover\", \"Shirley Watts\", \n                     \"Salvador Moreno\", \"Gas-Mart Central\", \"Gas-Mart West\", \"Oscar\u0027s Store\"];\n  \n  const headerRow \u003d [\"Item\", \"Stack Size\", \"Cost per Item\"].concat(storeNames);\n  sheet.getRange(1, 1, 1, headerRow.length).setValues([headerRow]);\n  \n  // Sample data\n  const sampleData \u003d [\n    [\"Lumber\", 25, 5, \"Yes\", \"Yes\", \"No\", \"Yes\", \"No\", \"No\", \"Yes\", \"No\"],\n    [\"Plywood\", 10, 12, \"Yes\", \"No\", \"Yes\", \"No\", \"Yes\", \"No\", \"No\", \"Yes\"],\n    [\"Nails\", 50, 0.5, \"Yes\", \"Yes\", \"Yes\", \"Yes\", \"No\", \"Yes\", \"No\", \"No\"],\n    [\"Screws\", 40, 0.75, \"No\", \"Yes\", \"Yes\", \"No\", \"Yes\", \"Yes\", \"Yes\", \"No\"]\n  ];\n  \n  sheet.getRange(2, 1, sampleData.length, headerRow.length).setValues(sampleData);\n  \n  // Format\n  sheet.setFrozenRows(1);\n  sheet.setFrozenColumns(3);\n}\n\n/**\n * Clear store queue and reset to default order\n * Useful for testing different scenarios\n */\nfunction resetStoreQueue() {\n  const stores \u003d [\"Dan\u0027s Hardware\", \"Handy Hank\u0027s\", \"Albert Hoover\", \"Shirley Watts\", \n                 \"Salvador Moreno\", \"Gas-Mart Central\", \"Gas-Mart West\", \"Oscar\u0027s Store\"];\n  \n  PropertiesService.getScriptProperties().setProperty(\"storeQueue\", JSON.stringify(stores));\n  Logger.log(`Store queue reset to default: ${stores.join(\u0027, \u0027)}`);\n}\n\n/**\n * Run a simulation with multiple delivery cycles\n * @param {number} cycles - Number of cycles to simulate (default: 5)\n */\nfunction runDeliverySimulation(cycles \u003d 5) {\n  for (let i \u003d 0; i \u003c cycles; i++) {\n    Logger.log(`\u003d\u003d\u003d\u003d\u003d Starting Simulation Cycle ${i + 1} \u003d\u003d\u003d\u003d\u003d`);\n    \n    // Optimize deliveries\n    optimizeDeliveries();\n    \n    // Process next order\n    processNextOrder();\n    \n    Logger.log(`\u003d\u003d\u003d\u003d\u003d Completed Simulation Cycle ${i + 1} \u003d\u003d\u003d\u003d\u003d`);\n    \n    // Small delay to avoid rate limits\n    Utilities.sleep(1000);\n  }\n  \n  Logger.log(`Simulation completed: ${cycles} cycles`);\n}"}]}